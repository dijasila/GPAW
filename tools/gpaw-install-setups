#!/usr/bin/env python

from __future__ import print_function
import os
import fnmatch
import urllib2
from StringIO import StringIO
import tarfile
from optparse import OptionParser
import re


usage = '%prog [OPTION]\n  or:  %prog [OPTION] INSTALLDIR'
description = ('In first form, show available setups and GPAW setup paths.  '
               'In second form, download and install gpaw-setups into '
               'INSTALLDIR/[setups-package-name-and-version].')


p = OptionParser(usage=usage, description=description)
p.add_option('--version', metavar='VERSION',
             help='download VERSION of setups or pseudopotentials.  '
             'Run without arguments to display a list of versions.  '
             'VERSION can be the full URL or a part such as  '
             '\'0.8\' or \'0.6.6300\'')
p.add_option('--tarball', metavar='FILENAME',
             help='unpack and install from local tarball FILENAME '
             'instead of downloading')
p.add_option('--sg15', action='store_true',
             help='install SG15 pseudopotentials rather than PAW setups.')
p.add_option('--register', action='store_true',
             help='run non-interactively and register install path in '
             'GPAW setup search paths.  This is done by adding lines to '
             '~/.gpaw/rc.py')
p.add_option('--no-register', action='store_true',
             help='run non-interactively and do not register install path in '
             'GPAW setup search paths')
opts, args = p.parse_args()
nargs = len(args)


if opts.register and opts.no_register:
    p.error('Conflicting options specified on whether to register '
            'setup install paths in configuration file.  Try not specifying '
            'some options.')


def get_gpaw_setup_file_urls():
    setups_page = 'https://wiki.fysik.dtu.dk/gpaw/_sources/setups/setups.txt'
    response = urllib2.urlopen(setups_page)
    pattern = 'https://wiki.fysik.dtu.dk/gpaw-files/gpaw-setups-*.tar.gz'
    urls = [line.strip() for line in response
            if fnmatch.fnmatch(line.strip(), pattern)]
    return urls


sg15_page = 'http://fpmd.ucdavis.edu/qso/potentials/sg15_oncv/'

def get_sg15_file_urls():
    response = urllib2.urlopen(sg15_page)
    # (This primitive way actually produces two hits per file)
    pattern = re.compile(r'sg15_oncv_upf_\d\d\d\d-\d\d-\d\d.tar.gz')
    matches = pattern.findall(response.read())
    sg15_files = list(set(matches))
    sg15_files.sort(reverse=True)
    sg15_urls = [''.join([sg15_page, fname])
                 for fname in sg15_files]
    return sg15_urls


# The sg15 file is a tarbomb.  We will later defuse it by untarring
# into a subdirectory, so we don't leave a ghastly mess on the
# unsuspecting user's system.

if not opts.tarball:
    if opts.sg15:
        urls = get_sg15_file_urls()
    else:
        urls = get_gpaw_setup_file_urls()

    def print_urls(urls, marked=None):
        for url in urls:
            pageurl, fname = url.rsplit('/', 1)
            #print(pageurl, fname)
            domain = pageurl.split('//', 1)[1].split('/', 1)[0]
            if url == marked:
                marking = ' [*]'
            else:
                marking = '    '
            print(' %s %s' % (marking, url))

    if len(urls) == 0:
        p.error('For some reason, no setup packages were found.  Probably'
                'this script is out of date.  Please rummage around GPAW '
                'web page until solution is found.')

    if opts.version:
        matching_urls = [url for url in urls if opts.version in url]
        if len(matching_urls) > 1:
            p.error('More than one setup file matches version "%s":\n'
                    '%s' % (opts.version, '\n'.join(matching_urls)))
        elif len(matching_urls) == 0:
            p.error('\nNo setup matched the specified version "%s".\n'
                    'Available setups are:\n'
                    '%s' % (opts.version, '\n'.join(urls)))
        assert len(matching_urls) == 1
        url = matching_urls[0]
    else:
        url = urls[0]

    print('Available setups and pseudopotentials')
    print_urls(urls, url)
    print()

def print_setups_info():
    try:
        import gpaw
    except ImportError, e:
        p.error("Cannot import 'gpaw'.  GPAW does not appear to be installed."
                " %s" % e)
    npaths = len(gpaw.setup_paths)
    if npaths == 0:
        print('GPAW currently has no setup search paths')
    else:
        print('Current GPAW setup paths in order of search priority:')
        for i, path in enumerate(gpaw.setup_paths):
            print('%4d. %s' % (i + 1, path))

if nargs == 0:
    print_setups_info()
    print()
    progname = p.get_prog_name()
    print('Run %s DIR to install newest setups into DIR.' % progname)
    print('Run %s DIR --version=VERSION to install VERSION (from above).'
          % progname)
    print('See %s --help for more info.' % progname)
    raise SystemExit
elif len(args) != 1:
    p.error('No more than one DIR expected.  Please try --help.')


targetpath = args[0]


if opts.tarball:
    print('Reading local tarball %s' % opts.tarball)
    targzfile = tarfile.open(opts.tarball)
    tarfname = opts.tarball
else:
    tarfname = url.rsplit('/', 1)[1]
    print('Selected %s.  Downloading...' % tarfname)
    response = urllib2.urlopen(url)
    targzfile = tarfile.open(fileobj=StringIO(response.read()))


if not os.path.exists(targetpath):
    os.makedirs(targetpath)

assert tarfname.endswith('.tar.gz')
setup_dirname = tarfname.rsplit('.', 2)[0]  # remove .tar.gz ending
setup_path = os.path.abspath(os.path.join(targetpath, setup_dirname))
if tarfname.startswith('sg15'):
    # Defuse tarbomb
    if not os.path.isdir(setup_path):
        os.mkdir(setup_path)
    targetpath = os.path.join(targetpath, setup_dirname)

print('Extracting tarball into %s' % targetpath)
targzfile.extractall(targetpath)
assert os.path.isdir(setup_path)
print('Setups installed into %s.' % setup_path)


# Okay, now we have to maybe edit people's rc files.
rcfiledir = os.path.join(os.environ['HOME'], '.gpaw')
rcfilepath = os.path.join(rcfiledir, 'rc.py')


# We could do all this by importing the rcfile as well and checking
# whether things are okay or not.
rcline1 = 'from gpaw import setup_paths'
rcline2 = "setup_paths.insert(0, '%s')" % setup_path

# Run interactive mode unless someone specified a flag requiring otherwise
interactive_mode = not (opts.register or opts.no_register)

register_path = False

if interactive_mode:
    answer = raw_input('Register this setup path in %s? [y/n] ' % rcfilepath)
    if answer.lower() in ['y', 'yes']:
        register_path = True
    elif answer.lower() in ['n', 'no']:
        print('As you wish.')
    else:
        print('What do you mean by "%s"?  Assuming "n".' % answer)
else:
    if opts.register:
        assert not opts.no_register
        register_path = True
    else:
        assert opts.no_register

if register_path:
    # First we create the file
    if not os.path.exists(rcfiledir):
        os.makedirs(rcfiledir)
    if not os.path.exists(rcfilepath):
        tmpfd = open(rcfilepath, 'w')  # Just create empty file
        tmpfd.close()

    for line in open(rcfilepath):
        if line.startswith(rcline2):
            print('It looks like the path is already registered in %s.'
                  % rcfilepath)
            print('File will not be modified at this time.')
            break
    else:
        rcfd = open(rcfilepath, 'a')
        print(rcline1, file=rcfd)
        print(rcline2, file=rcfd)
        print('Setup path registered in %s.' % rcfilepath)

        # Note: If called twice during the same run, this will *not* have
        # been updated with the newly edited lines as the info was already
        # imported!  Would need a reload.
        print_setups_info()
else:
    print('You can manually register the setups by adding the')
    print('following two lines to %s:' % rcfilepath)
    print()
    print(rcline1)
    print(rcline2)
    print()
print('Installation complete.')
