#!/usr/bin/env python
# -*- coding: utf-8 -*-

# Emacs: treat this as -*- python -*-

from optparse import OptionParser


parser = OptionParser(usage='%prog [options] element[s]',
                      version='%prog 0.1')
parser.add_option('-s', '--summary', action='store_true',
                  default=False,
                  help='Do a summary.')
parser.add_option('--lcao', type='string', metavar='basis',
                  help='Do a LCAO calculation.')

opt, args = parser.parse_args()

import os
import sys
import pickle
import tempfile
from math import sqrt

import numpy as npy
from ase.atoms import Atoms
from ase.data import atomic_names, covalent_radii, atomic_numbers

from gpaw import Calculator, ConvergenceError

b0 = {'Ni': 2.18, 'Pt': 2.73, 'Ru': 2.35, 'Na': 3.30, 'Mg': 3.65, 'Li': 2.94, 'Pd': 2.26, 'Fe': 1.83, 'He': 2.74, 'C': 1.29, 'F': 1.41, 'H': 0.75, 'Mo': 2.48, 'O': 1.22, 'Ne': 3.12, 'P': 1.88, 'S': 1.90, 'V': 2.44, 'N': 1.11, 'Kr': 3.77, 'Ag': 2.65, 'Al': 2.99, 'Au': 2.57, 'Ga': 2.84, 'Cr': 2.35, 'Cu': 2.29, 'B': 1.71, 'Ca': 3.69, 'Cd': 2.99, 'K': 4.14, 'La': 2.65, 'Nb': 2.52, 'Rh': 2.35, 'Si': 2.22, 'Sr': 4.05, 'Ti': 2.48, 'Zn': 2.60, 'Zr': 2.73}
b0 = {'Ni': 2.15, 'Pd': 2.40, 'Pt': 2.57, 'Ru': 2.21, 'Na': 3.30, 'Nb': 2.37, 'Mg': 3.87, 'Li': 3.12, 'Pb': 2.88, 'Rb': 4.37, 'Ti': 2.33, 'Rh': 2.21, 'Be': 1.91, 'Ba': 3.80, 'La': 2.81, 'Si': 2.22, 'As': 2.26, 'Fe': 1.84, 'Sr': 4.29, 'Mo': 2.33, 'He': 2.85, 'C': 1.29, 'B': 1.71, 'F': 1.41, 'H': 0.75, 'K': 4.14, 'Mn': 2.20, 'O': 1.24, 'Ne': 3.06, 'P': 1.88, 'S': 1.90, 'V': 2.29, 'N': 1.11, 'Kr': 4.00, 'Zn': 2.76, 'Ag': 2.65, 'Cl': 1.99, 'Ca': 3.91, 'Ir': 2.39, 'Al': 2.81, 'Cd': 3.17, 'Ge': 2.39, 'Ar': 2.08, 'Au': 2.57, 'Zr': 2.57, 'Ga': 2.84, 'Cs': 4.85, 'Cr': 2.21, 'Cu': 2.27}

b0 = {'Ni': 2.150, 'Pd': 2.496,
      'Pt': 2.35,
      'Ru': 2.122, 'Na': 3.300,
      'Nb': 1.99,
      'Mg': 4.3, 'Li': 3.270, 'Pb': 2.880, 'Rb': 4.375, 'Ti': 2.05, 'Rh': 2.232, 'Be': 2.25, 'Ba': 4.5, 'La': 2.968, 'Si': 2.220, 'As': 2.124, 'Fe': 1.843, 'Sr': 4.547, 'Mo': 1.95, 'He': 2.850, 'C': 1.290, 'B': 1.710, 'F': 1.413, 'H': 0.753, 'K': 4.107, 'Mn': 1.85, 'O': 1.240, 'Ne': 3.061, 'P': 1.880, 'S': 1.900, 'Kr': 4.4, 'V': 1.9, 'N': 1.110, 'Zn': 3.0, 'Ag': 2.650, 'Cl': 1.990, 'Ca': 4.3, 'Ir': 2.2, 'Al': 2.824, 'Cd': 3.5, 'Ge': 2.390, 'Ar': 2.35, 'Au': 2.570, 'Zr': 2.3, 'Ga': 2.840, 'Cs': 4.850, 'Cr': 1.85, 'Cu': 2.277}

colors = ['black', 'brown', 'red', 'orange',
          'yellow', 'green', 'blue', 'violet', 'gray', 'gray', 'gray', 'gray']

class TestAtom:
    def __init__(self, symbol):
        self.symbol = symbol
        if not os.path.isdir(symbol):
            os.mkdir(symbol)

        self.Z = atomic_numbers[symbol]
        self.name = atomic_names[self.Z]
        r = covalent_radii[self.Z]
        
        if symbol in b0:
            self.d0 = b0[symbol]
        else:
            self.d0 = 2 * r

        self.a = round(max(5 * r, 5.5) / 0.2 / 4) * 4 * 0.2

        gmin = 4 * int(self.a / 0.30 / 4 + 0.5)
        gmax = 4 * int(self.a / 0.14 / 4 + 0.5)
        
        self.ng = (gmax + 4 - gmin) // 4

        self.h = self.a / npy.arange(gmin, gmax + 4, 4)

    def run(self, summary, lcao):
        self.lcao = lcao
        tasks = ['eggbox', 'dimer']
        self.ready = True
        for task in tasks:
            filename = self.symbol + '/' + task + '.pckl'
            if os.path.isfile(filename):
                data = pickle.load(open(filename))
                if data:
                    for name, value in data.items():
                        setattr(self, name, value)
                else:
                    print 'Skipping', filename
                    self.ready = False
            else:
                self.ready = False
                if not summary:
                    self.pickle(task, [])
                    print 'Running', task, 'part for', self.symbol
                    getattr(self, task)()

    def pickle(self, task, attrs):
        data = {}
        for attr in attrs:
            data[attr] = getattr(self, attr)
        pickle.dump(data, open(self.symbol + '/' + task + '.pckl', 'w'))
        
    def eggbox(self):
        atom = Atoms(self.symbol, pbc=True, cell=(self.a, self.a, self.a))

        negg = 25
        self.Eegg = npy.zeros((self.ng, negg))
        self.Fegg = npy.zeros((self.ng, negg))
        
        for i in range(self.ng):
            h = self.h[i]
            print '%.3f:' % h,
            calc = Calculator(h=h, width=0.1, xc='PBE',
                              txt='%s/eggbox-%.3f.txt' % (self.symbol, h))
            if self.lcao:
                calc.set(eigensolver='lcao', basis=self.lcao)

            atom.set_calculator(calc)

            if self.lcao:
                calc.initialize(atom)
                calc.hamiltonian.lcao_forces = True

            for j in range(negg):
                x = h * j / (2 * negg - 2)
                atom[0].x = x
                try:
                    self.Eegg[i, j] = atom.get_potential_energy()
                except ConvergenceError:
                    sys.stdout.write('E')
                    break
                self.Fegg[i, j] = atom.get_forces()[0, 0]
                sys.stdout.write('.')
                sys.stdout.flush()
            print

        self.pickle('eggbox', ['Eegg', 'Fegg'])

    def dimer(self):
        dimer = Atoms([self.symbol, self.symbol],
                      pbc=True, cell=(self.a, self.a, self.a))

        self.Edimer = npy.zeros((self.ng, 7))
        self.Fdimer = npy.zeros((self.ng, 7, 2))
        
        q0 = self.d0 / sqrt(3)
        for i in range(self.ng):
            h = self.h[i]
            print '%.3f:' % h,
            calc = Calculator(h=h, width=0.1, xc='PBE',
                              txt='%s/dimer-%.3f.txt' % (self.symbol, h))
            if self.lcao:
                calc.set(eigensolver='lcao', basis=self.lcao)

            dimer.set_calculator(calc)

            if self.lcao:
                calc.initialize(dimer)
                calc.hamiltonian.lcao_forces = True

            y = []
            for j in range(-3, 4):
                q = q0 * (1 + j * 0.02)
                dimer.positions[1] = (q, q, q)
                try:
                    self.Edimer[i, j + 3] = dimer.get_potential_energy()
                except ConvergenceError:
                    sys.stdout.write('E')
                    break
                self.Fdimer[i, j + 3] = dimer.get_forces()[:, 0]
                sys.stdout.write('.')
                sys.stdout.flush()
            print

        self.pickle('dimer', ['Edimer', 'Fdimer'])

    def summary(self):
        dd = 0.02 * self.d0
        d = self.d0 + dd * npy.arange(-3, 4)
        M = npy.array([(1, 0, 0, 0),
                      (1, 1, 1, 1),
                      (0, 1, 0, 0),
                      (0, 1, 2, 3)])

        self.Edimer0 = npy.empty(self.ng)
        self.ddimer0 = npy.empty(self.ng)
        for i in range(self.ng):
            E = self.Edimer[i]
            ia = E.argsort()[0]
            E0 = E[ia]
            d0 = d[ia]
            if self.Fdimer[i, ia, 0] > 0.0:
                ib = ia + 1
            else:
                ib = ia - 1
            if 0 <= ib < 7:
                fa = self.Fdimer[i, ia, 0] * dd
                fb = self.Fdimer[i, ib, 0] * dd
                c = npy.linalg.solve(M, npy.array([E[ia], E[ib], fa, fb]))
                x = (ib - ia) * fa / (fa - fb)
                if 0 < x < 1:
                    E0 = c[0] + x * (c[1] + x * (c[2] + x * c[3]))
                    d0 = d[ia] + x * dd
            self.Edimer0[i] = E0
            self.ddimer0[i] = d0
        
        for i in range(self.ng):
            if abs(self.h[i] - 0.2) < 0.00001:
                break
        #print '%r: %.3f,' % (self.symbol, d0),
        self.Ediss = 2 * self.Eegg[:, 0] - self.Edimer0
        if 1:
            print ('%-2s %8.5f %8.5f %8.5f %8.5f %8.5f %8.5f' %
                   (self.symbol,
                    self.Edimer0[i:].ptp(),
                    self.Ediss[i:].ptp(),
                    self.Eegg.ptp(axis=1)[i:].max(),
                    self.ddimer0[i:].ptp(),
                    npy.abs(self.Fegg[i:]).max(1).max(),
                    npy.abs(self.Fdimer[i:].sum(2)).max(1).max()
                   ))
        if 1:
            import pylab as plt
            plt.figure(figsize=(10, 12))
            plt.subplots_adjust(left=0.07, right=0.97, bottom=0.05, wspace=0.25)
            p1 = plt.subplot(321)
            p2 = plt.subplot(322)
            for i in range(self.ng):
                x, y = f(d, self.Edimer[i] - self.Eegg[i, 0],
                         -self.Fdimer[i, :, 1] * sqrt(3))
                p1.plot(x, y, color=colors[i])
                x, y = f(npy.linspace(0, 0.5 * self.h[i], 25),
                         self.Eegg[i] - self.Eegg[i, 0],
                         -self.Fegg[i])
                p2.plot(x, y, color=colors[i])
            p3 = plt.subplot(323)
            p3.plot(self.h, self.Ediss - self.Ediss[-1], '-')
            p3.plot(self.h, self.Eegg.ptp(axis=1), '-')
            p4 = plt.subplot(324)
            p4.plot(self.h, npy.abs(self.Fegg).max(axis=1), '-')
            p4.plot(self.h, npy.abs(self.Fdimer.sum(axis=2)).max(axis=1), '-')
            p5 = plt.subplot(325)
            p5.plot(self.h, self.Edimer0 - self.Edimer0[-1], '-')
            p6 = plt.subplot(326)
            p6.plot(self.h, self.ddimer0 - self.ddimer0[-1], '-')
            plt.title(self.symbol)
            plt.show()

def f(x, y, dydx):
    dx = x[1] - x[0]
    x2 = npy.empty(3 * len(x))
    x2[::3] = x - 0.4 * dx
    x2[1::3] = x + 0.4 * dx
    x2[2::3] = x + 0.5 * dx
    y2 = npy.empty_like(x2)
    y2[::3] = y - dydx * 0.4 * dx
    y2[1::3] = y + dydx * 0.4 * dx
    y2[2::3] = npy.nan
    return x2, y2
def f(x, y, dydx):
    dx = x[1] - x[0]
    x2 = npy.empty(2 * len(x))
    x2[::2] = x - 0.5 * dx
    x2[1::2] = x + 0.5 * dx
    y2 = npy.empty_like(x2)
    y2[::2] = y - dydx * 0.5 * dx
    y2[1::2] = y + dydx * 0.5 * dx
    return x2, y2

if len(args) == 0:
    from gpaw.atom.generator import parameters
    args = parameters.keys()

if opt.summary:
    print '    deltaE   deltaEa  Eegg     deltad   Fegg     Ftot'

for symbol in args:
    ta = TestAtom(symbol)
    ta.run(opt.summary, opt.lcao)
    if opt.summary and ta.ready:
        ta.summary()

