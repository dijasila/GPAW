#!/usr/bin/env python
# Emacs: treat this as -*- python -*-

import sys
from optparse import OptionParser

description = 'Generate LCAO basis sets for the specified elements.'

parser = OptionParser(usage='%prog [options] [elements]',
                      version='%prog 0.1', description=description)
parser.add_option('-n', '--name', default=None, metavar='<name>',
                  help='name of generated basis files')
parser.add_option('-t', '--type', default='dzp', metavar='<type>',
                  help='type of basis.  For example: sz, dzp, qztp, '+
                  '4z3p.  [default: %default]')
parser.add_option('-E', '--energy-shift', metavar='<energy>', type='float',
                  default=.3,
                  help='use given energy shift to determine cutoff')
parser.add_option('-T', '--tail-norm', metavar='<norm>', type='string',
                  default='.03,.1,.4', dest='tailnorm',
                  help='use the given fraction to define the split'+
                  '-valence cutoff.  To specify multiple cutoffs, '+
                  'write: norm1,norm2,...')
parser.add_option('-D', '--energy-derivative', action='store_true',
                  dest='derivative',
                  help='include derivative of atomic orbital with respect '+
                  'to confinement potential inner cutoff as second '+
                  'basis function')
parser.add_option('-P', '--plot', action='store_true',
                  help='plot basis functions')
parser.add_option('-N', '--no-files', action='store_true',
                  help='Do not write basis function files')
parser.add_option('-X', '--exclude', action='store_true',
                  help='generate basis sets for all g2 elements, excluding '+
                  'those specified')
parser.add_option('--rcut-max', type='float', default=16., metavar='<rcut>',
                  help='max cutoff for confined atomic orbitals.  This '+
                  'option has no effect on orbitals with smaller cutoff '+
                  '[default/Bohr: %default]')
parser.add_option('--rcut-pol-rel', type='float', default=1.0,
                  metavar='<rcut>',
                  help='polarization function cutoff relative to largest'+
                  ' single-zeta cutoff [default: %default]')
parser.add_option('--rchar-pol-rel', type='float', default=None,
                  metavar='<rchar>',
                  help='characteristic radius of Gaussian when not using '+
                  'interpolation scheme, relative to rcut')
parser.add_option('--gaussians', type='int', metavar='<n>',
                  help='use the specified number of Gaussians for '+
                  'polarization function interpolation')
parser.add_option('--vconf-amplitude', type='float', default=12.,
                  metavar='<alpha>',
                  help='set proportionality constant of smooth confinement '+
                  'potential [default: %default]')
parser.add_option('--vconf-rstart-rel', type='float', default=.6,
                  metavar='<ri/rc>',
                  help='set inner cutoff for smooth confinement potential '+
                  'relative to hard cutoff [default: %default]')
parser.add_option('--vconf-sharp-confinement', action='store_true',
                  help='use sharp rather than smooth confinement potential')
parser.add_option('--debug', action='store_true',
                  help='use gpaw-DEBUG mode')

opts, args = parser.parse_args()

if __name__ == '__main__' and len(args) == 0 and not opts.exclude:
    parser.print_help()
    sys.exit(0)

from gpaw.atom.generator import Generator
from gpaw.atom.basis import BasisMaker
from gpaw.atom import polarization

if opts.exclude: # Invert selection of elements
    from gpaw.testing import g2
    # If the user specifies N:<reference_system> then remember that
    # because we don't want to exclude those
    special_args = [arg for arg in args if ':' in arg]

    # List of the actual element names in argv
    elements = [arg.split(':')[0] for arg in args]
    inverted_args = [arg for arg in g2.atoms.keys() if not arg in elements]
    inverted_args.remove('Mg') # g2 contains no Mg reference systems

    # Now re-add those we remembered earlier
    inverted_args.extend(special_args)

    args = inverted_args
    if len(args) == 0:
        print 'Another job well done!'
        sys.exit(0)

def parse_basis_name(name):
    """Parse any basis type identifier: 'sz', 'dzp', 'qztp', '4z3p', ... """
    letter2number = {'s' : 1, 'd' : 2, 't' : 3, 'q' : 4}
    number2letter = 'Xsdtq56789'

    newchars = ['', 'z', '', 'p']
    zetacount = letter2number.get(name[0])
    if zetacount is None:
        zetacount = int(name[0])
    assert name[1] == 'z'
    newchars[0] = number2letter[zetacount]
    if len(name) == 2:
        polcount = 0
        newchars[-1] = ''
    elif len(name) == 3:
        assert name[-1] == 'p'
        polcount = 1
    else:
        assert len(name) == 4 and name[-1] == 'p'
        polcount = letter2number.get(name[2])
        if polcount is None:
            polcount = int(name[2])
        newchars[2] = number2letter[polcount]
    return zetacount, polcount, ''.join(newchars)

def main():
    zetacount, polcount, basistype = parse_basis_name(opts.type)
    referencefiles = [None] * len(args)
    reference_atom_indices = [None] * len(args)
    if polcount > 0:
        symbols = []
        for i, arg in enumerate(args):
            # Parse argument as <symbol>:<reference-file>:<nuclear index>.
            symbol_and_file = arg.split(':')
            symbol = symbol_and_file[0]
            symbols.append(symbol)
            if len(symbol_and_file) > 1:
                referencefiles[i] = symbol_and_file[1] # filename
            if len(symbol_and_file) == 3:
                reference_atom_indices[i] = int(symbol_and_file[2])
    else:
        symbols = args

    if opts.name is not None:
        name = '%s.%s' % (opts.name, basistype)
    else:
        name = basistype

    for symbol, referencefile, referenceindex in zip(symbols, referencefiles,
                                                     reference_atom_indices):
        bm = BasisMaker(symbol, name, gtxt=None)

        if opts.no_files:
            figfile = None
        else:
            figfile = '%s.%s.png' % (symbol, name)
        tailnorm = [float(norm) for norm in opts.tailnorm.split(',')]
        vconf_args = None
        if not opts.vconf_sharp_confinement:
            vconf_args = opts.vconf_amplitude, opts.vconf_rstart_rel
            
        basis = bm.generate(zetacount, polcount,
                            tailnorm=tailnorm,
                            energysplit=opts.energy_shift,
                            referencefile=referencefile,
                            referenceindex=referenceindex,
                            rcutpol_rel=opts.rcut_pol_rel,
                            rcutmax=opts.rcut_max,
                            ngaussians=opts.gaussians,
                            rcharpol_rel=opts.rchar_pol_rel,
                            vconf_args=vconf_args,
                            include_energy_derivatives=opts.derivative)
        if opts.plot:
            bm.plot(basis, title=referencefile, filename=figfile)
        if not opts.no_files:
            basis.write_xml()
    if opts.plot and opts.no_files:
        import pylab
        pylab.show()

if __name__ == '__main__':    
    main()
